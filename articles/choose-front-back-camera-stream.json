{"title":"How to choose between front and back camera stream","slug":"choose-front-back-camera-stream","html":"<p><a href=\"https://caniuse.com/#feat=stream\">Most of the browsers nowadays</a>, including mobile browsers, allow the applications to retrieve and use the data stream coming directly from the user&#39;s device camera. But it&#39;s very common for the devices nowadays to have more than one camera available and we might have a preference which of these cameras is better suited for our app&#39;s needs. Fortunately, the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Media_Streams_API\">Media Stream API</a> has us covered.</p>\n<h2 id=\"media-stream-api\">Media Stream API</h2>\n<p>Let&#39;s first remind ourselves how do we access the video stream from the user&#39;s camera at all. The API sits in <code>navigator.mediaDevices</code> and is generic in terms of what kind of media stream it serves. We must specify. that we&#39;re particularly interested in video stream. This selects the proper device as well as displays the informative permission prompt for the user. If we requested video only, the browser will ask for a camera access. If we also wants audio, the prompt will include both camera and microphone.</p>\n<figure>\n  <img src=\"/articleimgs/camera-permissions.png\" alt=\"Chrome's permissions dialog for video and audio stream\" />\n  <figcaption>Chrome's permissions dialog for video and audio stream</figcaption>\n</figure>\n\n<pre><code>const stream = await navigator.mediaDevices.getUserMedia({\n    video: true,\n    audio: true\n})</code></pre><p>The API is asynchronous – we&#39;ll get the stream when the user accepts the prompt and the browser finds the proper devices. If any of these fail, our Promise will get rejected.</p>\n<p>In case we successfully acquired the stream, we can start manipulating it. The simplest thing we can do with it is to redirect it to a <code>&lt;video&gt;</code> element. In most cases, the <code>&lt;video&gt;</code> element has its source specified as a static file, but it also can have any stream as its source – including the one we get from the user&#39;s device. We need to attach it programatically:</p>\n<pre><code>const video = document.querySelector(&#39;video&#39;);\nvideo.srcObject = stream;\nvideo.play();</code></pre><p>Now, our <code>&lt;video&gt;</code> element will transmit the stream from the camera. So if the front camera is in use it will act as a mirror. But how do we ensure the proper one is used?</p>\n<h2 id=\"selecting-facing-mode-of-the-video-stream\">Selecting facing mode of the video stream</h2>\n<p>When we were acquiring the stream, we passed an object as a <code>getUserMedia</code> parameter. This object is a stream constraint definition. We only constrained the stream to include video (and audio) so far. But we can apply tighter constraint:</p>\n<pre><code>const stream = await navigator.mediaDevices.getUserMedia({\n    video: {\n        facingMode: &#39;user&#39;\n    }\n})</code></pre><p>Here, we put an object including <code>facingMode</code> property as a video constraint, instead of simple <code>true</code> that accepted any kind of video input. With constraint, we suggest the browser for what kind of video stream it should look for. In the example, we set it to <code>user</code>-facing camera – a.k.a. selfie camera, or the front one. Alternatively, we can specify we want to face <code>environment</code>, which is what is observed by the back camera.</p>\n<p>The constraint set this way only works as a suggestion, though – in case we run this code on a device equipped with back camera only, we&#39;d get the environment-facing stream anyway, as it&#39;s the only one available and it&#39;s still better to use whatever we have available instead of failing in most scenarios. But if our requirement is strict and we need to use the front camera or no camera, we can set an additional constraint using <code>exact</code>:</p>\n<pre><code>const stream = await navigator.mediaDevices.getUserMedia({\n    video: {\n        facingMode: {\n            exact: &#39;user&#39;\n        }\n    }\n})</code></pre><p>Now, if the device only has an environment-facing camera, we&#39;d not get any stream and the Promise will be rejected with <code>OverconstrainedError</code>.</p>\n<h2 id=\"more-constraints\">More constraints</h2>\n<p>Facing mode is not the only constraint specified by the Media Stream API. We may see the full list of constraint options using <code>navigator.mediaDevices.getSupportedConstraints()</code> call. And this list might be quite impressive. This is what Chrome 80 on macOS lists as available:</p>\n<pre><code>{\n    aspectRatio: true\n    autoGainControl: true\n    brightness: true\n    channelCount: true\n    colorTemperature: true\n    contrast: true\n    deviceId: true\n    echoCancellation: true\n    exposureCompensation: true\n    exposureMode: true\n    exposureTime: true\n    facingMode: true\n    focusDistance: true\n    focusMode: true\n    frameRate: true\n    groupId: true\n    height: true\n    iso: true\n    latency: true\n    noiseSuppression: true\n    pointsOfInterest: true\n    resizeMode: true\n    sampleRate: true\n    sampleSize: true\n    saturation: true\n    sharpness: true\n    torch: true\n    whiteBalanceMode: true\n    width: true\n    zoom: true\n    videoKind: true\n    pan: true\n    tilt: true\n}</code></pre><p>Obviously, some of these constraint only make sense for audio and others for video streams.</p>\n<p>The ones that might also be frequently used are these related with video resolution:</p>\n<pre><code>const stream = await navigator.mediaDevices.getUserMedia({\n    video: {\n        width: 1280,\n        height: 720\n    }\n})</code></pre><p>Note that like with <code>facingMode</code>, by default this is only a suggestion for what kind of stream we are looking for and the browser might as well provide the one with different size. We might again use <code>exact</code> modifier to ask for exactly the size specified, but in case of resolution it&#39;s probably wiser to specify the minimum size we accept, using <code>min</code> modifier:</p>\n<pre><code>const stream = await navigator.mediaDevices.getUserMedia({\n    video: {\n        width: {\n            min: 1280\n        },\n        height: {\n            min: 720\n        }\n    }\n})</code></pre><p>The browser now will not provide a stream if it&#39;s not possible to find one with at least 1280x720 size.</p>\n<h2 id=\"selecting-both-size-and-facing-mode\">Selecting both size and facing mode</h2>\n<p>As the constraint is an object, nothing stops us from specifying more requirements, possibly with different modifiers. The browser will try to match as many as possible when providing the stream and in case we used <code>exact</code> or <code>min</code> modifiers that can&#39;t be satisfied, it will again reject the promise with <code>OverconstrainedError</code>.</p>\n<pre><code>const stream = await navigator.mediaDevices.getUserMedia({\n    video: {\n        facingMode: &#39;environment&#39;,\n        width: {\n            min: 1280\n        },\n        height: {\n            min: 720\n        }\n    }\n})</code></pre><p>In this example, we&#39;re asking for the stream that should face the environment (back camera) when possible, but we also accept if only the front camera is available. For size we do not accept the sizes smaller than 1280 in width or 720 in height.</p>\n","image":"/articleimgs/black-camera-mounted-on-tripod.pexels.jpg","tags":["Media Capture API","Camera & Microphone"],"description":"Most of the browsers nowadays, including mobile browsers, allow the applications to retrieve and use the data stream coming directly from the user's device camera. But it's very common for the devices nowadays to have more than one camera available and we might have a preference which of these cameras is better suited for our app's needs. Fortunately, the Media Stream API has us covered.","author":"<p><a href=\"https://adambar.pl\">Adam Bar</a></p>\n","weight":1,"source":"wwcd"}